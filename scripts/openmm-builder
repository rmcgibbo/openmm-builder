#!/usr/bin/env python

##############################################################################
# Imports
##############################################################################

# check imports and complain nicely
requirements = ['pystache', 'traits', 'traitsui']
for r in requirements:
    try:
        __import__(r)
    except ImportError:
        print('#'*75)
        print('ERROR: openmm-builder requires %s' % r)
        print('%s can be downloaded from:' % r)
        print('    https://pypi.python.org/pypi/%s' % r)
        print('#'*75)
        raise

# stdlib
import os
import signal

# traits imports
# we need to make sure we're using qt right at the beginning
# because on my machine, wx (the default) doesn't work at all (?)
from traits.etsconfig.api import ETSConfig
ETSConfig.toolkit = 'qt4'
from traits.api import HasTraits, Instance, Button, Code
from traitsui.api import View, Item, Group, HGroup, HSplit, spring
from pyface.api import FileDialog, OK

# 3rd party
import pystache

# this package
from openmm_builder.config import (InputFile, Forcefield, Integrator, System,
                                   Simulation, Reporters)
from openmm_builder.runner import OpenMMScriptRunner

##############################################################################
# Classes
##############################################################################


class App(HasTraits):
    #-- Trait Definitions ----------------------------------
    # (just create an empty one as the default for each trait)
    inputfile = Instance(InputFile(), InputFile)
    forcefield = Instance(Forcefield(), Forcefield)
    integrator = Instance(Integrator(), Integrator)
    system = Instance(System(), System)
    simulation = Instance(Simulation(), Simulation)
    reporters = Instance(Reporters(), Reporters)

    def __init__(self, **traits):
        # dynamically register so that when any trait changes, it
        # triggers the script to be rerendered
        for t in self.all_trait_names():
            e = getattr(self, t, None)
            if e:
                e.on_trait_change(self.update_display)

        super(App, self).__init__(**traits)

    display = Code
    save = Button('Save Script!')
    run = Button('Run Script!')

    def _save_fired(self):
        dialog = FileDialog(action="save as", default_filename='myopenmm.py')
        dialog.open()
        if dialog.return_code == OK:
            with open(os.path.join(dialog.directory, dialog.filename), 'w') as f:
                f.write(str(self.display))

    def _run_fired(self):
        runner = OpenMMScriptRunner(openmm_script_code=self.display)
        runner.configure_traits()
        

    renderer = pystache.Renderer()
    template = pystache.parse(u'''
    ##########################################################################
    # this script was generated by openmm-builder. to customize it further,
    # you can save the file to disk and edit it with your favorite editor.
    ##########################################################################
    
    from __future__ import print_function
    from simtk.openmm.app import *
    from simtk.openmm import *
    from simtk.unit import *
    from sys import stdout

    print('Loading...')
    pdb = PDBFile('{{inputfile.file}}')
    forcefield = ForceField('{{forcefield.protein}}'{{#forcefield.water_active}}, '{{forcefield.water}}'{{/forcefield.water_active}})

    system = forcefield.createSystem(pdb.topology, nonbondedMethod={{system.nonbonded_method}},
        {{#system.nonbonded_cutoff_active}}nonbondedCutoff={{system.nonbonded_cutoff}},{{/system.nonbonded_cutoff_active}} constraints={{system.constraints}}, rigidWater={{system.rigid_water}})
    integrator = {{integrator.kind}}Integrator({{#integrator.stochastic_active}}{{integrator.temperature}}, {{integrator.friction}}, {{/integrator.stochastic_active}}{{integrator.timestep}})

    platform = Platform.getPlatformByName('Reference')

    simulation = Simulation(pdb.topology, system, integrator, platform)
    simulation.context.setPositions(pdb.positions)
    {{#simulation.minimize}}simulation.minimizeEnergy(maxIterations={{simulation.minimize_max_iters}}){{/simulation.minimize}}

    print('Starting')
    {{#reporters.dcd_active}}simulation.reporters.append(DCDReporter('{{reporters.dcd_out}}', {{reporters.dcd_freq}})){{/reporters.dcd_active}}
    {{#reporters.statedata_active}}simulation.reporters.append(StateDataReporter(stdout, {{reporters.statedata_freq}}, step=True,
        potentialEnergy=True, temperature=True)){{/reporters.statedata_active}}
    simulation.step({{simulation.n_steps}})
    print('Done')
    ''')


    #-- Trait View Definitions -----------------------------
    view = View(
        HSplit(
            Group(
                Group(
                    # pane 1
                    Group(Item('inputfile', show_label=False),
                          Item('forcefield', show_label=False),
                          label='General'),
                    # pane 2
                    Item('integrator', show_label=False, label='Integ.'),
                    # pane 3
                    Item('system', show_label=False),
                    # pane 4
                    Group(Item('simulation', show_label=False),
                          Item('reporters', show_label=False),
                          label='Simulation'),
                    layout='tabbed',),
                # put some springs around the save button, so it goes
                # in the middle of the column
                #HGroup(spring, Item('save', show_label=False), spring)),
                HGroup(spring, Item('save', show_label=False),
                               Item('run', show_label=False), spring)),
            # and now this goes over on the right
            Item('display', show_label=False, width=0.7),),
        style='custom',
        title='OpenMM Script Builder',
        resizable=True)

    def update_display(self):
        contents = self.renderer.render(self.template, self)
        # cheat a little bit to fix the formatting in the template string...
        # it has four extra spaces in front of every line from being declared
        # above, and the first line is empty. This makes it look better in
        # the code above, but isn't how we want it displayed. so lets chop
        # that stuff off.
        self.display = os.linesep.join([line[4:] for line in contents.split(os.linesep)[1:]])

if __name__ == '__main__':
    # make the control-c signal kill the app
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    App().configure_traits()
