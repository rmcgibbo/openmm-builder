#!/usr/bin/env python
# we need to make sure we're using qt right at the beginning
# because on my machine, wx (the default) doesn't work at all (?)


##############################################################################
# Imports
##############################################################################

# check imports and complain nicely
requirements = ['pystache', 'traits', 'traitsui']
for r in requirements:
    try:
        __import__(r)
    except ImportError:
        print('#'*75)
        print('ERROR: openmm-builder requires %s' % r)
        print('%s can be downloaded from:' % r)
        print('    https://pypi.python.org/pypi/%s' % r)
        print('#'*75)
        raise

# stdlib
import sys
import os
import signal

# traits imports
from traits.etsconfig.api import ETSConfig
ETSConfig.toolkit = 'qt4'
from traits.api import (HasTraits, Int, Enum, Float, Instance, Regex,
                        Button, Unicode, Bool, Code, File, Any)
from traitsui.api import (View, Item, Group, Handler,  VGroup, HGroup,
                          HSplit, spring)
from pyface.api import FileDialog, OK
# 3rd party
import pystache

try:
    import simtk.unit
except ImportError:
    print('#'*75)
    print 'ERROR: openmm-builder require simtk.unit, a part of OpenMM'
    print 'OpenMM can be downloaded from'
    print '    https://simtk.org/home/openmm'
    print '#*75'
    raise

##############################################################################
# New Traits
##############################################################################

# DIRTY HACK HACK HACK HACK HACK
# replace the __str__ function in simtk.unit.Quantity with a new version
# of our creation that outputs a representation that is suitable for use
# in an input piece of source code

# for example, using the old __str__, we would get
# (2.0*femotosecond).__str__() == '2.0 fs'
# but with this __str__, we get
# (2.0*femotosecond).__str__() == '2.0*femtosecond'

# we need this because during the templating and the rendering of the
# traitvalue into the traitui, the str() method is called on the object
def _new_str_(self):
    uname = self.unit.get_name()
    if uname.startswith('/'):
        return str(self._value) + uname
    return '%s*%s' % (self._value, uname)
simtk.unit.Quantity.__str__ = _new_str_
# END DIRTY HACK

# add a few aliases to the unit package, so that if someone types them
# inside the traitsui input box, they'll be parsed correctly
simtk.unit.fs = simtk.unit.femtosecond
simtk.unit.ps = simtk.unit.picosecond
simtk.unit.nm = simtk.unit.nanometers

class UnittedFloat(Any):
    """Trait corresponding to a float with units (from simtk.unit)
    """
    unit = Instance(simtk.unit.Unit)

    def __init__(self, default, **traits):
        """Create a UnittedFloat with a default value.
        The appropriate units for the trait will be extracted from
        the default value.

        Parameters
        ----------
        default : simtk.units.Quantity
            The default value of the trait.
        """
        super(UnittedFloat, self).__init__(default, **traits)
        self.unit = default.unit

    def validate(self, object, name, value):
        parsed_val = self._parse(object, name, value)
        try:
            if not parsed_val.unit.is_compatible(self.unit):
                self.error(object, name, value)
        except Exception as e:
            self.error(object, name, value)
        return parsed_val

    def _parse(self, object, name, value):
        try:
            # either just eval it
            v = eval(value, simtk.unit.__dict__)
        except Exception as e:
            try:
                # or try splitting it into two components, and multiplying
                # them. This enables something like "2.0 femtoseconds"
                # to be parsed correctly, with the implicit multiplication
                pre, post = value.split(None, 1)
                v = float(pre) * eval(post, simtk.unit.__dict__)
            except:
                self.error(object, name, value)
        return v


##############################################################################
# Classes
##############################################################################

class InputFile(HasTraits):
    file = File(os.path.abspath(os.path.curdir), filter=['*.pdb'])

    view = View(Group('file', show_border=True, label='Input File'))


class Forcefield(HasTraits):
    #-- Trait Definitions ----------------------------------
    protein = Enum('amber99sb.xml', ['amber03.xml', 'amber03_gbvi.xml',
                                     'amber03_obc.xml', 'amber10.xml',
                                     'amber10_gbvi.xml', 'amber10_obc.xml',
                                     'amber96.xml', 'amber96_gbvi.xml',
                                     'amber96_obc.xml', 'amber99_gbvi.xml',
                                     'amber99_obc.xml', 'amber99sb.xml',
                                     'amber99sbildn.xml', 'amber99sbnmr.xml'],
                    label='protein',
                    help='which forcefield to use for the protein')
    water = Enum('tip3p.xml', ['spce.xml', 'tip3p.xml', 'tip4pew.xml',
                               'tip5p.xml'],
                    label='water',
                    help='which forcefield to use for water')
    water_active = Bool(True, help='''flag indicating whether the "water"
        variable is actually required. to be set dynamically by the value
        of protein (i.e. if protein indicates an implicit solvent...)''')

    def _protein_changed(self, protein):
        self.water_active = not (("gbvi" in protein) or ("obc" in protein))

    #-- Trait View Definitions ----------------------------------
    main_group = Group(Item(name='protein'))
    water_group = Group(Item(name='water'),
        visible_when='water_active')
    view = View(Group(main_group, water_group, show_border=True,
        label='Forcefield'), resizable=True)


class Integrator(HasTraits):
    #-- Trait Definitions ----------------------------------
    # general traits
    timestep = UnittedFloat(2.0*simtk.unit.femtosecond)
    kind = Enum('Langevin', ['Verlet', 'Langevin', 'Brownian'])
    stochastic_active = Bool(True, help='''flag indicating whether or not
        the special options for stochastic integrators should be
        displayed''')

    def _kind_changed(self, kind):
        self.stochastic_active = (kind in ["Langevin", "Brownian"])

    # traits for stochastic integrators only only:
    temperature = UnittedFloat(300.0*simtk.unit.kelvin)
    friction = UnittedFloat(91.0/simtk.unit.picosecond)

    #-- Trait View Definitions ----------------------------------
    main_group = Group('kind', 'timestep',
        show_border=True,)

    stochastic_group = Group('friction', 'temperature',
        label='Addition info for stochastic integrators',
        show_border=True,
        visible_when='stochastic_active',)

    view = View(
        Group(main_group, stochastic_group,
        label='Integrator Options',
        show_border=True),
        resizable=True,)


class System(HasTraits):
    #-- Trait Definitions ----------------------------------
    nonbonded_method = Enum('PME', ['NoCutoff', 'CutoffNonPeriodic',
                                    'CutoffPeriodic', 'Ewald', 'PME'])
    nonbonded_cutoff = UnittedFloat(10*simtk.unit.nanometers)
    constraints = Enum('None', ['None', 'HBonds', 'HAngles', 'AllBonds'])
    rigid_water = Bool(True)
    nonbonded_cutoff_active = Bool(True, help='''flag indicating whether
        or not the nonbonded_cutoff option is required (depends on the
        nonbonded_method)''')

    def _nonbonded_method_changed(self, nonbonded_method):
        self.nonbonded_cutoff_active = (nonbonded_method != 'NoCutoff')

    #-- Trait View Definitions ----------------------------------
    main_group = Group('nonbonded_method', 'constraints', 'rigid_water')
    cutoff_group = Group(Item('nonbonded_cutoff'),
        visible_when = 'nonbonded_cutoff_active')
    view = View(Group(main_group, cutoff_group, show_border=True,
        label='System Options'), resizable=True)


class Reporters(HasTraits):
    dcd_active = Bool(True, label='Use DCDReporter')
    dcd_freq = Int(100, help='frequency to print to dcd file (timesteps)',
        label='DCD freq. [steps]')
    dcd_out = Regex('output.dcd', regex='.+\.dcd$', label='DCD output')

    statedata_active = Bool(True, label='Use StateDataReporter')
    statedata_freq = Int(100, label='StateData Freq. [steps]')

    main_group = Group('dcd_active', 'statedata_active')
    dcd_group = Group('dcd_freq', 'dcd_out',
        show_border=True,
        label='DCDReporter Options',
        visible_when='dcd_active')
    statedata_group=Group('statedata_freq',
        show_border=True,
        label='StateDataReporter Options',
        visible_when='statedata_active')
    view = View(Group(main_group, dcd_group, statedata_group,
                      show_border=True,
                      label='Reporters',
                ), resizable=True)


class Simulation(HasTraits):
    #-- Trait Definitions ----------------------------------
    n_steps = Int(1000, help='Number of time steps to run', label='Number of steps')

    minimize = Bool(True, help='Run minimization first', label='Minimize First')
    minimize_max_iters = Int(100, help='''Maximum number of iterations of
        minimization to run''', label='Max minimization iterations')

    #-- Trait View Definitions ----------------------------------
    main_group = Group('n_steps')
    minimize_group = Group('minimize', 'minimize_max_iters',
        show_border=True,
        label='Minimization Options',
        visible_when = 'minimize')
    view = View(Group(main_group, minimize_group, show_border=True,
                      label='Simulation Options'), resizable=True)


class App(HasTraits):
    #-- Trait Definitions ----------------------------------
    # (just create an empty one as the default for each trait)
    inputfile = Instance(InputFile(), InputFile)
    forcefield = Instance(Forcefield(), Forcefield)
    integrator = Instance(Integrator(), Integrator)
    system = Instance(System(), System)
    simulation = Instance(Simulation(), Simulation)
    reporters = Instance(Reporters(), Reporters)

    def __init__(self, **traits):
        # dynamically register so that when any trait changes, it
        # triggers the script to be rerendered
        for t in self.all_trait_names():
            e = getattr(self, t, None)
            if e:
                e.on_trait_change(self.update_display)

        super(App, self).__init__(**traits)

    display = Code
    save = Button('Save Script!')

    def _save_fired(self):
        dialog = FileDialog(action="save as", default_filename='myopenmm.py')
        dialog.open()
        if dialog.return_code == OK:
            with open(os.path.join(dialog.directory, dialog.filename), 'w') as f:
                f.write(str(self.display))

    renderer = pystache.Renderer()
    template = pystache.parse(u'''
    ##########################################################################
    # this script was generated by openmm-builder. to customize it further,
    # you can save the file to disk and edit it with your favorite editor.
    ##########################################################################

    from simtk.openmm.app import *
    from simtk.openmm import *
    from simtk.unit import *
    from sys import stdout

    print('Loading...')
    pdb = PDBFile('{{inputfile.file}}')
    forcefield = ForceField('{{forcefield.protein}}'{{#forcefield.water_active}}, '{{forcefield.water}}'{{/forcefield.water_active}})

    system = forcefield.createSystem(pdb.topology, nonbondedMethod={{system.nonbonded_method}},
        {{#system.nonbonded_cutoff_active}}nonbondedCutoff={{system.nonbonded_cutoff}},{{/system.nonbonded_cutoff_active}} constraints={{system.constraints}}, rigidWater={{system.rigid_water}})
    integrator = {{integrator.kind}}Integrator({{#integrator.stochastic_active}}{{integrator.temperature}}, {{integrator.friction}}, {{/integrator.stochastic_active}}{{integrator.timestep}})

    simulation = Simulation(pdb.topology, system, integrator)
    simulation.context.setPositions(pdb.positions)
    {{#simulation.minimize}}simulation.minimizeEnergy(maxIterations={{simulation.minimize_max_iters}}){{/simulation.minimize}}

    print('Starting')
    {{#reporters.dcd_active}}simulation.reporters.append(DCDReporter('{{reporters.dcd_out}}', {{reporters.dcd_freq}}){{/reporters.dcd_active}}
    {{#reporters.statedata_active}}simulation.reporters.append(StateDataReporter(stdout, {{reporters.statedata_freq}}, step=True,
        potentialEnergy=True, temperature=True)){{/reporters.statedata_active}}
    simulation.step({{simulation.n_steps}})
    print('Done')
    ''')


    #-- Trait View Definitions ----------------------------------
    view = View(
        HSplit(
            Group(
                Group(
                    # pane 1
                    Group(Item('inputfile', show_label=False),
                          Item('forcefield', show_label=False),
                          label='Input'),
                    # pane 2
                    Item('integrator', show_label=False, label='Integ.'),
                    # pane 3
                    Item('system', show_label=False),
                    # pane 4
                    Group(Item('simulation', show_label=False),
                          Item('reporters', show_label=False),
                          label='Simulation'),
                    layout='tabbed',),
                # put some springs around the save button, so it goes
                # in the middle of the column
                HGroup(spring, Item('save', show_label=False), spring)),
            # and now this goes over on the right
            Item('display', show_label=False, width=0.7),),
        style='custom',
        title='OpenMM Script Builder',
        resizable=True)

    def update_display(self):
        contents = self.renderer.render(self.template, self)
        # cheat a little bit to fix the formatting in the template string...
        # it has four extra spaces in front of every line from being declared
        # above, and the first line is empty. This makes it look better in
        # the code above, but isn't how we want it displayed. so lets chop
        # that stuff off.
        self.display = os.linesep.join([line[4:] for line in contents.split(os.linesep)[1:]])

if __name__ == '__main__':
    # make the control-c signal kill the app
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    App().configure_traits()
